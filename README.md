# LombardFi
See [the protocol documentation on Gitbook](https://docs.lombard.fi) and [the technical overview.](https://docs.lombard.fi/developers/technical-overview)

LombardFi is an upcoming DeFi protocol that will provide functionality for custom, permissionless reputation-based undercollateralized loans. The smart contracts are meant to allow anyone to ask for an undercollateralized loan, whereas frontends can choose to filter borrowers, provide reputation-based metadata or verify their identities.

## High-level Overview
The protocol allows for 2 types of actors to interact: lenders and borrowers.

Anyone can become a borrower by deploying a Pool via the PoolFactory. 

The borrower must supply a set of parameters, equivalent to a termsheet in the traditional OTC lending world. These parameters will remain immutable throughout the lifecycle of the Pool, with one exception addressed later.

**Termsheet**

* A pool has a lent asset, an ERC20 token that the borrower wants to borrow. Lender supply this asset.
* A pool has a set of collateral assets, one or more ERC20 tokens that the borrower can supply as collateral at the time of borrow.
* A pool has a minimum and maximum supply of the lent asset. The minimum must be achieved to unlock borrowing and distribute yield to lenders.
* A pool has 3 timestamps: the start timestamp, active timestamp and maturity timestamp.
* A pool has a coupon, which is the yield generated by lenders for the term duration. This is different from APR (APR is annualized). 
* A pool has a loan-to-value ratio which says the minimum value of the collateral that must be supplied by the borrower for the pool.
* A pool has an origination fee, deducted from the borrowed amount at the point of borrow, and deposited into the protocol treasury.
* A pool is open to everyone (as a lender) by default. The borrower can choose to whitelist a certain address as a lender at any time, mimicking a private OTC deal.

All parameters in the termsheet are chosen by the borrower with the exception of the origination fee (defined at protocol level by the governance) and the start timestamp which is automatically set to the block timestamp at pool creation.

**Timestamps**

The start timestamp is set to the time at which the pool is created. 
Up until the active timestamp the pool is said to be *bonding*.
During the bonding period lenders can deposit the lent asset.

Between the active timestamp and the maturity timestamp the pool is said to be *active*.
Once a pool is active lenders can no longer deposit. 
* If the minimum supply is achieved the borrower can borrow all collected funds (all at once, partial borrows are not allowed). They must repay the loan by the end of the active period.
* If the minimum supply is not achieved the borrower cannot borrow. Lenders can instead redeem their deposits without the coupon. The borrowers can withdraw their upfront.

After the maturity timestamp the pool is said to be *mature*.
* If all debt was repaid lenders can redeem their deposit + the coupon on their deposit.
* If debt was partially repaid lenders can redeem a pro-rata distribution on the partial repayment + the coupon on their deposit + a pro-rata distribution of the collateral.
* If debt was not repaid lenders can redeem the coupon on their deposit + a pro-rata distribution of the collateral.

**Particularities**

Lenders that default are not punished by the system. Instead, the reputation problem is to be solved on the user interface level, where any number of on-chain or off-chain reputation/curation systems can be used. 

Anyone can repay the borrower's loan on behalf of the borrower. This is done for the greater flexibility of institutional borrowers, which will usually deploy the borrowed capital on centralized exchanges, and would prefer to repay with a hot wallet.

When creating a pool the borrower must supply the coupon for the maximum supply upfront. For example if the maximum is 1M DAI and the coupon is 6% then they must supply 60000 DAI in order to create the pool. This is done to guarantee yield to the lenders and to encourage the creation of high-quality pools by reputable actors. If the maximum supply is not achieved borrowers can withdraw the coupon for the unfilled amount.

When borrowing the collected funds the borrower must supply collateral of any subset of the collateral assets whose value satisfies the loan-to-value ratio.

Pools are OpenZeppelin Clones of an immutable pool implementation created in the constructor of `PoolFactory`.

Native Ether is not accepted. All assets must be ERC20 tokens.

Tokens with more than 18 decimals are not accepted due to concerns about mathematical precision and token sanity.

## Architecture
The `PoolFactory` is the contract that handles the creation of pools. When the contract is constructed, the immutable `Pool` implementation contract is created. Every pool is a clone of this contract. The `PoolFactory` also acts as a registry for deployed pools.

The `Router` is the entry point for all interactions with deployed pools.

The `OracleManager` is an oracle aggregator that can get prices from multiple oracle adapters. Every adapter must conform to the `IBasePriceOracle` interface. The oracle manager's strategy is not to combine prices but to have multiple oracle implementations in order of robustness. For example, first it tries Chainlink, then UniV3. Only Chainlink is supported at this moment with the Uniswap V3 TWAP oracle in development.

The `Treasury` is the address where the origination fee is forwarded to. This is intended to become a DAO treasury.

## Typical Flow
* Boris spots a profitable market-neutral opportunity for USDC on a centralized exchange. He wants to borrow USDC and provide collateral with WETH and/or WBTC. He wants a minimum of 1M DAI and a maximum of 20M DAI. He chooses a 500% LTV, and gives a 1.5% coupon for a 3-month term, amounting to a 6% APR. Deposits are open for 2 weeks.
* Boris creates a pool by calling `PoolFactory.createPool()` with the desired termsheet. To do that he has to supply 0.3M DAI as an upfront (1.5% * 20M DAI).
* Lena spots the pool and deposits 3M DAI by calling `Router.deposit()`.
* The initial 2 weeks are over. The pool is now active.
* Boris borrows all 3M DAI by calling `Router.borrow()`. To do that he has to supply collateral of value equal to 20% of the borrowed amount (0.6M DAI) to achieve a 500% LTV. He decides to give 10% of that in WETH and 90% of that in WBTC as he believes that WBTC is overvalued and WETH is undervalued.
* Boris withdraws the extra coupon for the unfilled 17M DAI by calling `Router.withdrawLeftovers()`. This amounts to 45K DAI. 
* Boris deploys the funds off-chain. After 2 1/2 months the off-chain opportunity has dried up. 
* Boris repays the borrowed 3M in time by calling `Router.repay()`. He gets back all collateral.
* The pool matures.
* Lena redeems her deposit (3M) + coupon (0.3M) by calling `Router.redeem()`.

## Tests
The codebase has unit tests for all contracts for 100% branch and line coverage, as well as end-to-end tests for scenarios and integration.

## Deployment
There is a number of deployment scripts under `scripts/` that allow for mainnet and testnet deployments.

## Areas of High Concern
The development team identified the following areas where they are unsure about the robustness of the protocol (in order of concern):
* Scenarios that lead to locked protocol value (dust due to mathematical imprecision is undesired but acceptable).
* Scenarios with pausing the protocol.
* Implementation of the Chainlink Oracle Adapter.
* Improper use of OpenZeppelin Clones.
* DOS / Griefing attacks against protocol users.
* Scenarios when the borrower defaults.
* Overflows in accounting variables in `Pool`.
* Flashloan attacks.
* Bad event design.

**Not of concern**
* Gas usage with the exception of the flows where a lender deposits and redeems.
* Malicious borrowers that do not repay
* Malicious upgrades by owner/governance
